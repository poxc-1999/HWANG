# Node.js 예제 실습 정리 (Chapter 1)

## ✅ 1-1: var 키워드를 사용한 변수 선언
- `var` 키워드를 사용하여 변수를 선언할 수 있다.
- 초기화하지 않으면 기본값은 `undefined`이다.

## ✅ 1-2: var의 중복 선언과 대입 예제
- `var`는 중복 선언을 허용한다.
- 선언과 대입을 분리하거나 동시에 가능하다.

## ✅ 1-3: 기본형 데이터의 불변성
- 기본형(문자열, 숫자 등)은 불변값이다.
- 변경이 아닌 새로운 값을 생성하여 대입한다.

## ✅ 1-4: 참조형 데이터의 할당
- 객체는 참조형 데이터로, 변수에 저장되는 것은 참조값이다.
- 참조형 데이터를 복사하면 같은 객체를 가리키게 된다.

## ✅ 1-5: 참조형 데이터 객체의 프로퍼티 재할당 예제
- 참조형 데이터의 프로퍼티는 자유롭게 변경 가능하다.

## ✅ 1-6: 객체 속성으로 배열을 할당한 중첩 참조 예제
- 객체 안에 배열 등 다른 참조형을 포함할 수 있다.

## ✅ 1-7: 기본형과 참조형 데이터 복사의 차이 예제
- 기본형은 값 복사, 참조형은 참조 복사로 동작한다.

## ✅ 1-8: 기본형 vs 참조형 변수 복사 후 값 변경 비교
- 참조형은 같은 객체를 공유하기 때문에 한 쪽 변경 시 다른 쪽도 영향을 받는다.

## ✅ 1-9: 객체 참조 복사 후 새 객체 재할당 시 영향 분석
- 참조형 복사 이후 새로운 객체를 재할당하면 참조가 끊어진다.

## ✅ 1-10: 객체 참조로 인한 가변성 문제 예제
- 함수 인자로 전달된 객체를 수정하면 원본도 바뀐다.

## ✅ 1-11: 불변성을 지켜 객체 복사를 통한 정보 변경 구현
- 원본 객체를 수정하지 않고 새 객체를 리턴하여 불변성을 유지한다.

## ✅ 1-12: 얕은 복사를 수행하는 객체 복사 함수 구현
- `for...in` 문을 이용하여 얕은 복사를 수행한다.

## ✅ 1-13: copyObject 함수를 활용한 객체 복사 및 변경 예제
- 얕은 복사 후 객체를 변경해도 원본은 유지된다.

## ✅ 1-14: 중첩 객체에서 얕은 복사의 한계 예제
- 내부 참조형은 그대로 복사되므로, 원본과 복사본이 연결된 상태가 된다.

## ✅ 1-16: 깊은 복사를 수행하는 재귀적 copyObjectDeep 함수 구현
- 중첩된 참조형까지 재귀적으로 복사하여 완전히 분리된 객체 생성.

## ✅ 1-17: 깊은 복사 후 원본과 복사본의 변경 분리 확인 예제
- 깊은 복사된 객체는 원본과 완전히 분리되어 있으며 변경이 독립적이다.

## ✅ 1-18: JSON 기반의 간단한 깊은 복사 구현 예제
- `JSON.stringify`와 `JSON.parse`를 활용한 깊은 복사.
- 함수, `undefined`, 순환 참조 등은 복사되지 않음.

## ✅ 1-19: 자동으로 undefined가 부여되는 3가지 경우 예제
- 값이 없는 변수, 존재하지 않는 프로퍼티 접근, return 없는 함수 호출 시 undefined가 발생.

## ✅ 1-20: undefined와 empty 배열 슬롯의 차이 예제
- `[undefined, undefined]`와 `new Array(2)`는 완전히 다름.
- 전자는 값이 `undefined`, 후자는 값 자체가 없음.

## ✅ 1-21: undefined와 빈 슬롯의 배열 순회 차이 예제
- `forEach`, `map`, `filter`, `reduce` 등의 동작에서 차이가 발생함.

## ✅ 1-22: undefined와 null의 비교 및 typeof 결과 예제
- `null == undefined`는 true, `===`은 false.
- `typeof null`은 `"object"`로 출력됨 (자바스크립트 설계상의 오래된 버그).

# Chapter 2: 실행 컨텍스트와 스코프

## ✅ 2-1: 실행 컨텍스트와 콜 스택
- 내부 함수에서 `var`로 다시 선언한 변수는 호이스팅되어 `undefined`로 출력된다.
- 콜 스택에 따라 내부 실행 컨텍스트가 우선 실행된다.

## ✅ 2-2: 매개변수와 변수 간 호이스팅 충돌
- 매개변수와 `var` 변수는 같은 이름일 경우 중복 선언되며, 나중에 선언된 것이 우선 적용된다.

## ✅ 2-3: 중복된 var 선언이 무시됨
- 여러 번 `var x` 선언이 있어도 실제로는 한 번만 선언된 것으로 처리되고 마지막 할당만 유효하다.

## ✅ 2-4: var 선언은 통합, 할당은 순차 실행
- `var`는 선언만 호이스팅되고, 할당은 원래 위치에 존재하여 순차적으로 실행된다.

## ✅ 2-5: 함수 선언 vs 변수 선언 충돌
- 동일한 이름일 경우 함수 선언이 먼저 호이스팅되지만,
- 이후 `var` 변수 선언이 함수 참조를 덮어쓰기 때문에 `b`는 변수로 처리된다.

## ✅ 2-6: 함수 선언문이 변수 선언보다 우선 적용됨
- 함수 선언이 먼저 호이스팅되고 실행되며, 이후 변수에 덮어쓰기 되지 않으면 유지된다.

## ✅ 2-7: 함수 표현식은 호이스팅되지 않음
- `var b = function() {}`는 변수 선언만 호이스팅되고 함수는 원래 자리에 남아 실행 시점까지 정의되지 않는다.

## ✅ 2-8: 함수 정의 방식 3가지
- 함수 선언문: 전체 호이스팅됨 → 선언 전 호출 가능
- 익명 함수 표현식: 변수만 호이스팅됨 → 선언 후에만 호출 가능
- 기명 함수 표현식: 변수 이름만 외부에서 사용 가능, 내부 함수명은 외부 참조 불가

## ✅ 2-9: 함수 선언문 vs 함수 표현식 (1)
- 함수 선언문은 전체가 호이스팅되어 먼저 호출 가능
- 함수 표현식은 선언 전 호출 시 `TypeError`

## ✅ 2-10: 함수 표현식의 호이스팅 예시 (2)
- `sum`은 선언과 동시에 함수 할당 → 호출 가능
- `multiply`는 변수 선언만 호이스팅 → 호출 시점에 함수가 할당되지 않아 에러

## ✅ 2-11: 함수 선언 중복 시 마지막 선언만 유효
- 함수 선언문이 여러 번 있을 경우, 마지막 선언이 앞선 정의를 덮어쓴다.

## ✅ 2-12: 함수 표현식은 덮어쓰기 방지에 유리함
- `var sum = function() {}`는 이후 재선언이 필요할 경우도 변수 재할당일 뿐
- 이전 호출에는 영향을 주지 않아 더 안전한 방식

## ✅ 2-13: 스코프 체인
- 내부 함수에서 같은 이름의 변수를 선언하면, 외부 스코프의 변수는 가려진다.
- 선언만 호이스팅되고 초기화 전에는 `undefined`가 출력된다.