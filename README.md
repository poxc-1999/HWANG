# Node.js 예제 실습 정리 (Chapter 1)

## ✅ 1-1: var 키워드를 사용한 변수 선언
- `var` 키워드를 사용하여 변수를 선언할 수 있다.
- 초기화하지 않으면 기본값은 `undefined`이다.

## ✅ 1-2: var의 중복 선언과 대입 예제
- `var`는 중복 선언을 허용한다.
- 선언과 대입을 분리하거나 동시에 가능하다.

## ✅ 1-3: 기본형 데이터의 불변성
- 기본형(문자열, 숫자 등)은 불변값이다.
- 변경이 아닌 새로운 값을 생성하여 대입한다.

## ✅ 1-4: 참조형 데이터의 할당
- 객체는 참조형 데이터로, 변수에 저장되는 것은 참조값이다.
- 참조형 데이터를 복사하면 같은 객체를 가리키게 된다.

## ✅ 1-5: 참조형 데이터 객체의 프로퍼티 재할당 예제
- 참조형 데이터의 프로퍼티는 자유롭게 변경 가능하다.

## ✅ 1-6: 객체 속성으로 배열을 할당한 중첩 참조 예제
- 객체 안에 배열 등 다른 참조형을 포함할 수 있다.

## ✅ 1-7: 기본형과 참조형 데이터 복사의 차이 예제
- 기본형은 값 복사, 참조형은 참조 복사로 동작한다.

## ✅ 1-8: 기본형 vs 참조형 변수 복사 후 값 변경 비교
- 참조형은 같은 객체를 공유하기 때문에 한 쪽 변경 시 다른 쪽도 영향을 받는다.

## ✅ 1-9: 객체 참조 복사 후 새 객체 재할당 시 영향 분석
- 참조형 복사 이후 새로운 객체를 재할당하면 참조가 끊어진다.

## ✅ 1-10: 객체 참조로 인한 가변성 문제 예제
- 함수 인자로 전달된 객체를 수정하면 원본도 바뀐다.

## ✅ 1-11: 불변성을 지켜 객체 복사를 통한 정보 변경 구현
- 원본 객체를 수정하지 않고 새 객체를 리턴하여 불변성을 유지한다.

## ✅ 1-12: 얕은 복사를 수행하는 객체 복사 함수 구현
- `for...in` 문을 이용하여 얕은 복사를 수행한다.

## ✅ 1-13: copyObject 함수를 활용한 객체 복사 및 변경 예제
- 얕은 복사 후 객체를 변경해도 원본은 유지된다.

## ✅ 1-14: 중첩 객체에서 얕은 복사의 한계 예제
- 내부 참조형은 그대로 복사되므로, 원본과 복사본이 연결된 상태가 된다.

## ✅ 1-16: 깊은 복사를 수행하는 재귀적 copyObjectDeep 함수 구현
- 중첩된 참조형까지 재귀적으로 복사하여 완전히 분리된 객체 생성.

## ✅ 1-17: 깊은 복사 후 원본과 복사본의 변경 분리 확인 예제
- 깊은 복사된 객체는 원본과 완전히 분리되어 있으며 변경이 독립적이다.

## ✅ 1-18: JSON 기반의 간단한 깊은 복사 구현 예제
- `JSON.stringify`와 `JSON.parse`를 활용한 깊은 복사.
- 함수, `undefined`, 순환 참조 등은 복사되지 않음.

## ✅ 1-19: 자동으로 undefined가 부여되는 3가지 경우 예제
- 값이 없는 변수, 존재하지 않는 프로퍼티 접근, return 없는 함수 호출 시 undefined가 발생.

## ✅ 1-20: undefined와 empty 배열 슬롯의 차이 예제
- `[undefined, undefined]`와 `new Array(2)`는 완전히 다름.
- 전자는 값이 `undefined`, 후자는 값 자체가 없음.

## ✅ 1-21: undefined와 빈 슬롯의 배열 순회 차이 예제
- `forEach`, `map`, `filter`, `reduce` 등의 동작에서 차이가 발생함.

## ✅ 1-22: undefined와 null의 비교 및 typeof 결과 예제
- `null == undefined`는 true, `===`은 false.
- `typeof null`은 `"object"`로 출력됨 (자바스크립트 설계상의 오래된 버그).

# Chapter 2: 실행 컨텍스트와 스코프

## ✅ 2-1: 실행 컨텍스트와 콜 스택
- 내부 함수에서 `var`로 다시 선언한 변수는 호이스팅되어 `undefined`로 출력된다.
- 콜 스택에 따라 내부 실행 컨텍스트가 우선 실행된다.

## ✅ 2-2: 매개변수와 변수 간 호이스팅 충돌
- 매개변수와 `var` 변수는 같은 이름일 경우 중복 선언되며, 나중에 선언된 것이 우선 적용된다.

## ✅ 2-3: 중복된 var 선언이 무시됨
- 여러 번 `var x` 선언이 있어도 실제로는 한 번만 선언된 것으로 처리되고 마지막 할당만 유효하다.

## ✅ 2-4: var 선언은 통합, 할당은 순차 실행
- `var`는 선언만 호이스팅되고, 할당은 원래 위치에 존재하여 순차적으로 실행된다.

## ✅ 2-5: 함수 선언 vs 변수 선언 충돌
- 동일한 이름일 경우 함수 선언이 먼저 호이스팅되지만,
- 이후 `var` 변수 선언이 함수 참조를 덮어쓰기 때문에 `b`는 변수로 처리된다.

## ✅ 2-6: 함수 선언문이 변수 선언보다 우선 적용됨
- 함수 선언이 먼저 호이스팅되고 실행되며, 이후 변수에 덮어쓰기 되지 않으면 유지된다.

## ✅ 2-7: 함수 표현식은 호이스팅되지 않음
- `var b = function() {}`는 변수 선언만 호이스팅되고 함수는 원래 자리에 남아 실행 시점까지 정의되지 않는다.

## ✅ 2-8: 함수 정의 방식 3가지
- 함수 선언문: 전체 호이스팅됨 → 선언 전 호출 가능
- 익명 함수 표현식: 변수만 호이스팅됨 → 선언 후에만 호출 가능
- 기명 함수 표현식: 변수 이름만 외부에서 사용 가능, 내부 함수명은 외부 참조 불가

## ✅ 2-9: 함수 선언문 vs 함수 표현식 (1)
- 함수 선언문은 전체가 호이스팅되어 먼저 호출 가능
- 함수 표현식은 선언 전 호출 시 `TypeError`

## ✅ 2-10: 함수 표현식의 호이스팅 예시 (2)
- `sum`은 선언과 동시에 함수 할당 → 호출 가능
- `multiply`는 변수 선언만 호이스팅 → 호출 시점에 함수가 할당되지 않아 에러

## ✅ 2-11: 함수 선언 중복 시 마지막 선언만 유효
- 함수 선언문이 여러 번 있을 경우, 마지막 선언이 앞선 정의를 덮어쓴다.

## ✅ 2-12: 함수 표현식은 덮어쓰기 방지에 유리함
- `var sum = function() {}`는 이후 재선언이 필요할 경우도 변수 재할당일 뿐
- 이전 호출에는 영향을 주지 않아 더 안전한 방식

## ✅ 2-13: 스코프 체인
- 내부 함수에서 같은 이름의 변수를 선언하면, 외부 스코프의 변수는 가려진다.
- 선언만 호이스팅되고 초기화 전에는 `undefined`가 출력된다.

## ✅ 2-14:
-  함수 객체인 `inner`를 console.dir()로 출력하면 [[Scopes]]라는 내부 슬롯이 보이며, 클로저가 외부 렉시컬 환경(예: b 변수)을 참조하고 있음을 확인할 수 있다.

## ✅ 2-15: 
- 내부 함수에서 외부 함수의 지역 변수 `b`에 접근하여 2를 출력한다. 이는 클로저의 대표적인 예이며, console.dir(inner)를 통해 inner가 상위 스코프를 참조하는 구조를 확인할 수 있다.

### ✅ 2-16:
-  `debugger;`를 사용하여 개발자 도구에서 실행을 일시 중지하고, 변수 `b`가 클로저를 통해 참조되는 것을 스코프 체인을 통해 시각적으로 확인할 수 있다.


# Chapter 3: 실행 컨텍스트와 this 바인딩

## ✅ 3-1: 브라우저 전역 공간에서의 this
- 브라우저 환경에서는 전역 공간의 `this`는 `window` 객체를 참조한다.

## ✅ 3-2: Node.js 전역 공간에서의 this
- Node.js 환경에서는 전역 공간의 `this`는 `global` 객체를 참조한다.

## ✅ 3-3: var 변수는 window의 프로퍼티
- `var`로 선언된 전역 변수는 `window.a`, `this.a` 등으로 접근 가능하다.

## ✅ 3-4: 전역 객체 프로퍼티와 변수 재할당
- `window.b = 2`처럼 직접 할당된 프로퍼티도 전역 변수처럼 작동하고 값 공유됨.

## ✅ 3-5: 전역 변수 삭제 불가 vs 프로퍼티 삭제 가능
- `var`로 선언된 변수는 `delete` 불가하지만 `window.c = ...` 방식은 삭제 가능.

## ✅ 3-6: 함수 vs 메서드 호출의 this
- 일반 함수 호출 시 `this`는 전역 객체, 객체 메서드 호출 시 `this`는 그 객체.

## ✅ 3-7: 점 표기 vs 대괄호 표기
- `obj.method()`와 `obj['method']()`는 동일한 this 바인딩 결과를 가진다.

## ✅ 3-8: 중첩 객체의 메서드 this 바인딩
- `obj.inner.method()`처럼 호출한 객체가 this가 된다.

## ✅ 3-9: 내부 함수는 외부 this를 계승하지 않음
- 내부 함수는 기본적으로 전역 객체를 this로 바인딩한다.

## ✅ 3-10: self = this 방식
- 내부 함수에서 외부 this를 유지하려면 `var self = this`로 참조를 보존.

## ✅ 3-11: 화살표 함수는 this를 상위 스코프에서 상속
- 자신만의 this를 바인딩하지 않음.

## ✅ 3-12: 콜백 함수의 this
- setTimeout 콜백은 전역 객체, 이벤트 핸들러는 이벤트 대상 요소를 this로 바인딩.

## ✅ 3-13: 생성자 함수의 this
- `new` 키워드로 생성 시 this는 새로 만들어지는 객체를 참조한다.

## ✅ 3-14: call로 this와 인자 전달
- `call(thisArg, arg1, ...)` 형식으로 함수 호출 시 this를 명시적으로 지정.

## ✅ 3-15: 메서드에도 call 사용 가능
- 객체의 메서드를 다른 객체에 바인딩해 재사용 가능.

## ✅ 3-16: apply는 인자 배열로 전달
- `apply(thisArg, [args])`는 인자를 배열 형태로 전달하는 점만 call과 다름.

## ✅ 3-17: 유사 배열 객체에 배열 메서드 적용
- `Array.prototype.slice.call(arguments)` 등을 통해 arguments나 NodeList를 배열로 변환 가능.

## ✅ 3-18: arguments, NodeList를 배열로 변환 후 forEach 사용
- `slice.call(...)` 혹은 `Array.from(...)`으로 진짜 배열처럼 반복문 사용 가능.

## ✅ 3-19: 문자열에도 배열 메서드 사용 가능
- `map`, `reduce` 등은 가능하지만 `push`는 오류 발생 (읽기 전용 속성).

## ✅ 3-20: Array.from으로 유사 배열을 배열로 변환
- ES6부터 유사 배열을 쉽게 변환 가능.

## ✅ 3-21: 생성자 내부에서 call/apply 사용
- 다른 생성자를 호출해 속성을 상속받을 수 있음.

## ✅ 3-22: forEach로 최대/최소값 계산
- 배열을 순회하며 직접 최대, 최소 계산.

## ✅ 3-23: apply로 Math.max/min에 배열 전달
- apply를 이용해 여러 인자를 배열 형태로 넘김.

## ✅ 3-24: 펼침 연산자(...)로 Math 함수 호출
- ES6의 spread 문법으로 더 간결하게 구현 가능.

## ✅ 3-25: bind로 this 고정한 새 함수 생성
- this와 일부 인자를 고정한 함수를 반환.
### ✅ 3-26: 
- bind 메서드를 사용하면 this와 일부 인자를 고정한 새로운 함수를 만들 수 있다. 이때 생성된 함수의 name 속성에는 원래 함수 이름 앞에 'bound '가 붙는다.

### ✅ 3-27:
-  일반 함수로 정의된 innerFunc는 this를 바인딩하지 않지만, call(this)를 통해 외부 함수의 this를 명시적으로 전달할 수 있다.

### ✅ 3-27.2:
- bind(this)를 사용하여 내부 함수가 외부 함수의 this를 그대로 사용할 수 있도록 고정한다. 이렇게 하면 innerFunc를 일반 호출해도 this가 obj로 유지된다.

### ✅ 3-28: 
- setTimeout의 콜백에서 this를 유지하려면 bind(this)를 사용해야 한다. 그냥 전달하면 this는 window가 되며, bind를 쓰면 원래 객체(this)가 유지된다.

### ✅ 3-29:
- 화살표 함수는 자신만의 this를 가지지 않고 상위 함수의 this를 계승한다. 따라서 별도로 bind나 call 없이도 외부 this를 사용할 수 있다.

### ✅ 3-30:
- forEach 등의 배열 메서드에 thisArg를 두 번째 인자로 전달하면 콜백 함수 내부에서 원하는 this를 사용할 수 있다. thisArg가 없으면 기본적으로 undefined나 window가 바인딩된다.

### ✅ 3-31: 
- thisArg를 지원하는 배열 메서드(forEach, map, filter 등) 및 Set, Map의 forEach 메서드를 정리한 목록이다. 콜백 함수 내부에서 명시적 this 바인딩이 가능하다.