# Node.js 예제 실습 정리 (Chapter 1)

## ✅ 1-1: var 키워드를 사용한 변수 선언
- `var` 키워드를 사용하여 변수를 선언할 수 있다.
- 초기화하지 않으면 기본값은 `undefined`이다.

## ✅ 1-2: var의 중복 선언과 대입 예제
- `var`는 중복 선언을 허용한다.
- 선언과 대입을 분리하거나 동시에 가능하다.

## ✅ 1-3: 기본형 데이터의 불변성
- 기본형(문자열, 숫자 등)은 불변값이다.
- 변경이 아닌 새로운 값을 생성하여 대입한다.

## ✅ 1-4: 참조형 데이터의 할당
- 객체는 참조형 데이터로, 변수에 저장되는 것은 참조값이다.
- 참조형 데이터를 복사하면 같은 객체를 가리키게 된다.

## ✅ 1-5: 참조형 데이터 객체의 프로퍼티 재할당 예제
- 참조형 데이터의 프로퍼티는 자유롭게 변경 가능하다.

## ✅ 1-6: 객체 속성으로 배열을 할당한 중첩 참조 예제
- 객체 안에 배열 등 다른 참조형을 포함할 수 있다.

## ✅ 1-7: 기본형과 참조형 데이터 복사의 차이 예제
- 기본형은 값 복사, 참조형은 참조 복사로 동작한다.

## ✅ 1-8: 기본형 vs 참조형 변수 복사 후 값 변경 비교
- 참조형은 같은 객체를 공유하기 때문에 한 쪽 변경 시 다른 쪽도 영향을 받는다.

## ✅ 1-9: 객체 참조 복사 후 새 객체 재할당 시 영향 분석
- 참조형 복사 이후 새로운 객체를 재할당하면 참조가 끊어진다.

## ✅ 1-10: 객체 참조로 인한 가변성 문제 예제
- 함수 인자로 전달된 객체를 수정하면 원본도 바뀐다.

## ✅ 1-11: 불변성을 지켜 객체 복사를 통한 정보 변경 구현
- 원본 객체를 수정하지 않고 새 객체를 리턴하여 불변성을 유지한다.

## ✅ 1-12: 얕은 복사를 수행하는 객체 복사 함수 구현
- `for...in` 문을 이용하여 얕은 복사를 수행한다.

## ✅ 1-13: copyObject 함수를 활용한 객체 복사 및 변경 예제
- 얕은 복사 후 객체를 변경해도 원본은 유지된다.

## ✅ 1-14: 중첩 객체에서 얕은 복사의 한계 예제
- 내부 참조형은 그대로 복사되므로, 원본과 복사본이 연결된 상태가 된다.

## ✅ 1-16: 깊은 복사를 수행하는 재귀적 copyObjectDeep 함수 구현
- 중첩된 참조형까지 재귀적으로 복사하여 완전히 분리된 객체 생성.

## ✅ 1-17: 깊은 복사 후 원본과 복사본의 변경 분리 확인 예제
- 깊은 복사된 객체는 원본과 완전히 분리되어 있으며 변경이 독립적이다.

## ✅ 1-18: JSON 기반의 간단한 깊은 복사 구현 예제
- `JSON.stringify`와 `JSON.parse`를 활용한 깊은 복사.
- 함수, `undefined`, 순환 참조 등은 복사되지 않음.

## ✅ 1-19: 자동으로 undefined가 부여되는 3가지 경우 예제
- 값이 없는 변수, 존재하지 않는 프로퍼티 접근, return 없는 함수 호출 시 undefined가 발생.

## ✅ 1-20: undefined와 empty 배열 슬롯의 차이 예제
- `[undefined, undefined]`와 `new Array(2)`는 완전히 다름.
- 전자는 값이 `undefined`, 후자는 값 자체가 없음.

## ✅ 1-21: undefined와 빈 슬롯의 배열 순회 차이 예제
- `forEach`, `map`, `filter`, `reduce` 등의 동작에서 차이가 발생함.

## ✅ 1-22: undefined와 null의 비교 및 typeof 결과 예제
- `null == undefined`는 true, `===`은 false.
- `typeof null`은 `"object"`로 출력됨 (자바스크립트 설계상의 오래된 버그).

# Chapter 2: 실행 컨텍스트와 스코프

## ✅ 2-1: 실행 컨텍스트와 콜 스택
- 내부 함수에서 `var`로 다시 선언한 변수는 호이스팅되어 `undefined`로 출력된다.
- 콜 스택에 따라 내부 실행 컨텍스트가 우선 실행된다.

## ✅ 2-2: 매개변수와 변수 간 호이스팅 충돌
- 매개변수와 `var` 변수는 같은 이름일 경우 중복 선언되며, 나중에 선언된 것이 우선 적용된다.

## ✅ 2-3: 중복된 var 선언이 무시됨
- 여러 번 `var x` 선언이 있어도 실제로는 한 번만 선언된 것으로 처리되고 마지막 할당만 유효하다.

## ✅ 2-4: var 선언은 통합, 할당은 순차 실행
- `var`는 선언만 호이스팅되고, 할당은 원래 위치에 존재하여 순차적으로 실행된다.

## ✅ 2-5: 함수 선언 vs 변수 선언 충돌
- 동일한 이름일 경우 함수 선언이 먼저 호이스팅되지만,
- 이후 `var` 변수 선언이 함수 참조를 덮어쓰기 때문에 `b`는 변수로 처리된다.

## ✅ 2-6: 함수 선언문이 변수 선언보다 우선 적용됨
- 함수 선언이 먼저 호이스팅되고 실행되며, 이후 변수에 덮어쓰기 되지 않으면 유지된다.

## ✅ 2-7: 함수 표현식은 호이스팅되지 않음
- `var b = function() {}`는 변수 선언만 호이스팅되고 함수는 원래 자리에 남아 실행 시점까지 정의되지 않는다.

## ✅ 2-8: 함수 정의 방식 3가지
- 함수 선언문: 전체 호이스팅됨 → 선언 전 호출 가능
- 익명 함수 표현식: 변수만 호이스팅됨 → 선언 후에만 호출 가능
- 기명 함수 표현식: 변수 이름만 외부에서 사용 가능, 내부 함수명은 외부 참조 불가

## ✅ 2-9: 함수 선언문 vs 함수 표현식 (1)
- 함수 선언문은 전체가 호이스팅되어 먼저 호출 가능
- 함수 표현식은 선언 전 호출 시 `TypeError`

## ✅ 2-10: 함수 표현식의 호이스팅 예시 (2)
- `sum`은 선언과 동시에 함수 할당 → 호출 가능
- `multiply`는 변수 선언만 호이스팅 → 호출 시점에 함수가 할당되지 않아 에러

## ✅ 2-11: 함수 선언 중복 시 마지막 선언만 유효
- 함수 선언문이 여러 번 있을 경우, 마지막 선언이 앞선 정의를 덮어쓴다.

## ✅ 2-12: 함수 표현식은 덮어쓰기 방지에 유리함
- `var sum = function() {}`는 이후 재선언이 필요할 경우도 변수 재할당일 뿐
- 이전 호출에는 영향을 주지 않아 더 안전한 방식

## ✅ 2-13: 스코프 체인
- 내부 함수에서 같은 이름의 변수를 선언하면, 외부 스코프의 변수는 가려진다.
- 선언만 호이스팅되고 초기화 전에는 `undefined`가 출력된다.

## ✅ 2-14: 함수 객채 내부 구조를 통해 클로저 스코프 확인
-  함수 객체인 `inner`를 console.dir()로 출력하면 [[Scopes]]라는 내부 슬롯이 보이며, 클로저가 외부 렉시컬 환경(예: b 변수)을 참조하고 있음을 확인할 수 있다.

## ✅ 2-15: 클로저로 상위 함수의 변수에 접근 및 함수 객체 구조 출력
- 내부 함수에서 외부 함수의 지역 변수 `b`에 접근하여 2를 출력한다. 이는 클로저의 대표적인 예이며, console.dir(inner)를 통해 inner가 상위 스코프를 참조하는 구조를 확인할 수 있다.

## ✅ 2-16:	클로저 스코프 체인을 디버거로 확인
-  `debugger;`를 사용하여 개발자 도구에서 실행을 일시 중지하고, 변수 `b`가 클로저를 통해 참조되는 것을 스코프 체인을 통해 시각적으로 확인할 수 있다.


# Chapter 3: 실행 컨텍스트와 this 바인딩

## ✅ 3-1: 브라우저 전역 공간에서의 this
- 브라우저 환경에서는 전역 공간의 `this`는 `window` 객체를 참조한다.

## ✅ 3-2: Node.js 전역 공간에서의 this
- Node.js 환경에서는 전역 공간의 `this`는 `global` 객체를 참조한다.

## ✅ 3-3: var 변수는 window의 프로퍼티
- `var`로 선언된 전역 변수는 `window.a`, `this.a` 등으로 접근 가능하다.

## ✅ 3-4: 전역 객체 프로퍼티와 변수 재할당
- `window.b = 2`처럼 직접 할당된 프로퍼티도 전역 변수처럼 작동하고 값 공유됨.

## ✅ 3-5: 전역 변수 삭제 불가 vs 프로퍼티 삭제 가능
- `var`로 선언된 변수는 `delete` 불가하지만 `window.c = ...` 방식은 삭제 가능.

## ✅ 3-6: 함수 vs 메서드 호출의 this
- 일반 함수 호출 시 `this`는 전역 객체, 객체 메서드 호출 시 `this`는 그 객체.

## ✅ 3-7: 점 표기 vs 대괄호 표기
- `obj.method()`와 `obj['method']()`는 동일한 this 바인딩 결과를 가진다.

## ✅ 3-8: 중첩 객체의 메서드 this 바인딩
- `obj.inner.method()`처럼 호출한 객체가 this가 된다.

## ✅ 3-9: 내부 함수는 외부 this를 계승하지 않음
- 내부 함수는 기본적으로 전역 객체를 this로 바인딩한다.

## ✅ 3-10: self = this 방식
- 내부 함수에서 외부 this를 유지하려면 `var self = this`로 참조를 보존.

## ✅ 3-11: 화살표 함수는 this를 상위 스코프에서 상속
- 자신만의 this를 바인딩하지 않음.

## ✅ 3-12: 콜백 함수의 this
- setTimeout 콜백은 전역 객체, 이벤트 핸들러는 이벤트 대상 요소를 this로 바인딩.

## ✅ 3-13: 생성자 함수의 this
- `new` 키워드로 생성 시 this는 새로 만들어지는 객체를 참조한다.

## ✅ 3-14: call로 this와 인자 전달
- `call(thisArg, arg1, ...)` 형식으로 함수 호출 시 this를 명시적으로 지정.

## ✅ 3-15: 메서드에도 call 사용 가능
- 객체의 메서드를 다른 객체에 바인딩해 재사용 가능.

## ✅ 3-16: apply는 인자 배열로 전달
- `apply(thisArg, [args])`는 인자를 배열 형태로 전달하는 점만 call과 다름.

## ✅ 3-17: 유사 배열 객체에 배열 메서드 적용
- `Array.prototype.slice.call(arguments)` 등을 통해 arguments나 NodeList를 배열로 변환 가능.

## ✅ 3-18: arguments, NodeList를 배열로 변환 후 forEach 사용
- `slice.call(...)` 혹은 `Array.from(...)`으로 진짜 배열처럼 반복문 사용 가능.

## ✅ 3-19: 문자열에도 배열 메서드 사용 가능
- `map`, `reduce` 등은 가능하지만 `push`는 오류 발생 (읽기 전용 속성).

## ✅ 3-20: Array.from으로 유사 배열을 배열로 변환
- ES6부터 유사 배열을 쉽게 변환 가능.

## ✅ 3-21: 생성자 내부에서 call/apply 사용
- 다른 생성자를 호출해 속성을 상속받을 수 있음.

## ✅ 3-22: forEach로 최대/최소값 계산
- 배열을 순회하며 직접 최대, 최소 계산.

## ✅ 3-23: apply로 Math.max/min에 배열 전달
- apply를 이용해 여러 인자를 배열 형태로 넘김.

## ✅ 3-24: 펼침 연산자(...)로 Math 함수 호출
- ES6의 spread 문법으로 더 간결하게 구현 가능.

## ✅ 3-25: bind로 this 고정한 새 함수 생성
- this와 일부 인자를 고정한 함수를 반환.

## ✅ 3-26: bind로 생성된 함수는 name 프로퍼티에 bound 접두사가 붙음
- bind 메서드를 사용하면 this와 일부 인자를 고정한 새로운 함수를 만들 수 있다. 이때 생성된 함수의 name 속성에는 원래 함수 이름 앞에 'bound '가 붙는다.

## ✅ 3-27: 내부 함수에 call로 외부 this를 전달
-  일반 함수로 정의된 innerFunc는 this를 바인딩하지 않지만, call(this)를 통해 외부 함수의 this를 명시적으로 전달할 수 있다.

## ✅ 3-27.2: bind로 내부 함수의 this를 외부와 동일하게 고정
- bind(this)를 사용하여 내부 함수가 외부 함수의 this를 그대로 사용할 수 있도록 고정한다. 이렇게 하면 innerFunc를 일반 호출해도 this가 obj로 유지된다.

## ✅ 3-28: setTimeout 내부에서 this 바인딩 유지 여부 비교 예제
- setTimeout의 콜백에서 this를 유지하려면 bind(this)를 사용해야 한다. 그냥 전달하면 this는 window가 되며, bind를 쓰면 원래 객체(this)가 유지된다.

## ✅ 3-29: thisArg를 지원하는 Array,Set,Map 메서드 목록
- 화살표 함수는 자신만의 this를 가지지 않고 상위 함수의 this를 계승한다. 따라서 별도로 bind나 call 없이도 외부 this를 사용할 수 있다.

## ✅ 3-30: forEach의 thisArg 인자로 this 바인딩 유지
- forEach 등의 배열 메서드에 thisArg를 두 번째 인자로 전달하면 콜백 함수 내부에서 원하는 this를 사용할 수 있다. thisArg가 없으면 기본적으로 undefined나 window가 바인딩된다.

## ✅ 3-31: 	thisArg를 지원하는 Array,Set,Map 메서드 목록
- thisArg를 지원하는 배열 메서드(forEach, map, filter 등) 및 Set, Map의 forEach 메서드를 정리한 목록이다. 콜백 함수 내부에서 명시적 this 바인딩이 가능하다.

# Chapter 4: 콜백 함수와 비동기 제어

## ✅ 4-1 : setInterval로 0부터 4까지 300ms 간격으로 출력하는 코드
- setInterval을 이용해 0부터 4까지 300ms 간격으로 콘솔에 출력하는 코드

## ✅ 4-2 : 콜백 함수로 구현된 setInterval 예제 (0부터 4까지 300ms 간격 출력)
- 콜백 함수를 변수로 선언하여 setInterval에 전달, 0부터 4까지 출력

## ✅ 4-3 : map() 메서드를 사용하여 배열의 각 요소에 5를 더하고, currentValue와 index를 출력하는 예제
- map() 메서드를 사용해 배열의 각 요소에 5를 더하고, currentValue와 index를 출력

## ✅ 4-4 : map() 메서드의 매개변수 순서 오류 사례 (index, currentValue를 잘못 사용하여 예상치 못한 결과 발생)
- map() 메서드 인자 순서 오류로 의도치 않은 결과가 발생하는 예제

## ✅ 4-5 : Array.prototype.map 메서드를 직접 구현한 코드
- Array.prototype.map을 직접 구현한 코드

## ✅ 4-6 : this 바인딩 동작 예제 (setTimeout, forEach, addEventListener에서의 this)
- setTimeout, forEach, addEventListener에서의 this 바인딩 동작 비교

## ✅ 4-7 : forEach 메서드에서 this 바인딩 문제 (콜백 함수에서 this가 전역 객체(Window)로 바인딩되는 예제)
- forEach에서 콜백 함수의 this가 객체가 아니라 전역(Window)으로 바인딩되는 현상

## ✅ 4-8 : self(this) 참조를 통한 내부 함수에서의 this 바인딩 유지 예제
- self(this) 변수를 사용해 내부 함수에서 외부 this 참조를 유지하는 예제

## ✅ 4-9 : setTimeout에서 객체 메서드를 직접 전달할 때의 this 바인딩 문제 (전역 obj1 참조)
- setTimeout에 객체 메서드를 직접 전달하면 this가 바뀌는 현상과 그 해결법

## ✅ 4-10 : 객체 메서드 복사, call 메서드 활용 및 setTimeout에서의 this 바인딩 동작 예제
- 객체 메서드 복사와 call, setTimeout에서의 this 바인딩 동작 예제

## ✅ 4-11 : bind 메서드를 사용하여 setTimeout에서 this를 원하는 객체로 고정하는 예제
- bind 메서드를 이용해 setTimeout에서 this를 원하는 객체로 고정

## ✅ 4-12 : setTimeout을 중첩하여 콜백 지옥(callback hell) 형태로 동작하는 예제 (커피 주문 순서 출력)
- setTimeout을 중첩 호출(콜백 지옥)하여 커피 주문 과정을 출력

## ✅ 4-13 : 콜백 함수를 분리하여 setTimeout을 순차적으로 실행하는 콜백 지옥 개선 예제 (커피 주문)
- 콜백 함수를 분리하여 setTimeout을 순차 실행, 콜백 지옥을 개선

## ✅ 4-14 : Promise와 then 체이닝을 이용하여 비동기 작업을 순차적으로 처리하는 예제 (커피 주문)
- Promise와 then 체이닝으로 비동기 커피 주문을 순차적으로 처리

## ✅ 4-15 : 고차 함수와 Promise를 활용한 비동기 함수 체이닝 예제 (커피 주문)
- 고차 함수와 Promise를 활용해 함수 체이닝으로 커피 주문 처리

## ✅ 4-16 : 제너레이터(generator)와 yield를 활용하여 비동기 순차 작업을 구현한 예제 (커피 주문)
- 제너레이터(generator)와 yield를 사용해 비동기 순차 작업 구현

## ✅ 4-17 : async/await를 활용하여 비동기 작업을 동기식 코드처럼 처리하는 예제 (커피 주문)
- async/await로 비동기 작업을 동기식 코드처럼 처리하는 커피 주문 예제

# Chapter 5: 클로저와 고급 함수 활용

## ✅ 5-1 : 중첩 함수(inner)를 통해 외부 함수 변수(a)를 참조 및 변경하는 클로저 예제
- 중첩 함수(inner)를 통해 외부 함수의 변수(a)를 참조 및 변경하는 클로저 예제

## ✅ 5-2 : 내부 함수에서 외부 함수 변수(a)를 증가시키고 값을 반환하는 클로저 예제
- 내부 함수에서 외부 변수(a)를 증가시키고 값을 반환하는 클로저 예제

## ✅ 5-3 : 외부 함수 실행 후 반환된 내부 함수가 외부 변수(a)를 지속적으로 참조하는 클로저 예제
- 외부 함수가 반환한 내부 함수가 외부 변수(a)를 지속적으로 참조하는 클로저

## ✅ 5-4 : 즉시 실행 함수와 클로저를 활용한 setInterval 및 이벤트 리스너에서의 상태 유지 예제
- 즉시 실행 함수와 클로저로 setInterval, eventListener에서 상태 유지 예제

## ✅ 5-5 : 클로저의 메모리 해제 방법(return, setInterval, eventListener에서 참조 끊기)
-  클로저의 메모리 해제(return, setInterval, eventListener에서 참조 끊기)

## ✅ 5-6 : 클로저를 활용하여 각 리스트 아이템 클릭 시 해당 과일명을 알림으로 출력하는 예제
- 클로저를 이용해 리스트 클릭 시 해당 과일명을 알림으로 출력

## ✅ 5-7 : 공통 함수(alertFruit)를 이벤트 리스너로 사용하여 리스트 클릭 시 과일명 출력하는 예제
- 공통 함수(alertFruit)를 이벤트 리스너로 사용하여 리스트 클릭 시 과일명 출력

## ✅ 5-8 : bind를 이용해 이벤트 리스너에 각 과일명을 전달하여 클릭 시 해당 과일명을 출력하는 예제
- bind로 이벤트 리스너에 각 과일명을 전달, 클릭 시 해당 과일명 출력

## ✅ 5-9 : 고차 함수를 이용해 각 과일별로 개별 클로저를 만들어 클릭 시 해당 과일명 알림을 출력하는 예제
- 고차 함수로 각 과일별로 개별 클로저를 만들어 알림 출력

## ✅ 5-10 : 객체 메서드를 이용한 자동차 연료 및 이동 거리 관리 예제
- 객체 메서드로 자동차의 연료, 이동거리 관리

## ✅ 5-11 : 클로저를 활용하여 자동차 상태(연료, 이동거리 등)를 은닉하고 관리하는 예제
- 클로저로 자동차 상태(연료, 이동거리 등) 은닉 및 관리

## ✅ 5-12 : Object.freeze로 외부 변경을 막는 클로저 기반 자동차 객체 예제
- Object.freeze를 사용해 외부 변경을 막는 클로저 기반 자동차 객체

## ✅ 5-13 : bind 메서드를 사용한 부분 적용 함수(partial application) 구현 예제
- bind 메서드로 부분 적용 함수(partial application) 구현

## ✅ 5-14 : 직접 구현한 partial 함수로 부분 적용과 this 바인딩 활용 예제
- 직접 구현한 partial 함수로 부분 적용과 this 바인딩 활용

## ✅ 5-15 : 직접 구현한 partial 함수에 자리 표시자(placeholder)를 적용한 고급 부분 적용 함수 예제
- partial 함수에 자리 표시자(placeholder)를 도입한 고급 부분 적용 함수

## ✅ 5-16 : 디바운스(debounce) 함수를 직접 구현하여 이벤트 과다 발생 시 실행 제한하는 예제
- 디바운스(debounce) 함수를 직접 구현해 이벤트 과다 발생 시 실행 제한

## ✅ 5-17 : 2인자 함수(Math.max, Math.min 등)를 커링(curry)하여 사용하는 예제
- 커링(curry)으로 2인자 함수(Math.max, Math.min 등) 활용

## ✅ 5-18 : 5인자 함수를 커링(curry)하여 순차적으로 인자를 전달하는 예제
- 커링(curry)으로 5인자 함수를 순차적으로 인자 전달하며 실행


